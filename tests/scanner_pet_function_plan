# Scanner Pet WeakAura Documentation

## Overview
This WeakAura automatically manages raid target markers (icons) on enemies in World of Warcraft, providing intelligent marking based on priorities and combat situations.

Aura will be used to mark targets with triangle (mark 4) when they have aggro on player.  This is to establish when pets do not have aggro and mark that enemy unit with triangle so the pet attacks and gains aggro.  The triangle (mark 4) is removed once the player (or players in group) lose aggro or the pet gains aggro.  Adding and removing the marks as needed on targets that have aggro on player.

Aura should be an original WeakAura custom function that can be implemented in the weak auras addon.

While building the weakaura, building_auras.txt will be used as a primary resource, follow instuctions and verify with resources to avoid errors.

## Core Features
1. Scan system for targets and nameplates to gather info for the mark management system.
2. Dynamic interrupt marking and unmarking with diamond using cast detection.
3. Dynamic Aggro-based triangle marking and unmarking system.
4. Priority-based marking system for other targets.
5. Mark management system.

### 2. Target-Based Scan
1. Target-based scan is a scan of targets encountered as targets are switched manually in game. As the target info is collected it is used to set marks and gather information used by the target-based scan to set marks.
2. Records unique info on targets as seen during this initial scan:
   - First time seen: Record GUID and timestamp
   - Second time seen: Set skull mark if no skull mark exists
3. Skull Mark (Mark 8) Implementation:
   - MUST set skull mark on the FIRST unit that is targeted twice
   - Once skull is set on a unit, that unit becomes the designated skull target
   - No other unit should receive skull mark while designated skull target exists
   - Skull designation only clears when:
     - The unit dies
     - Combat ends
     - The WeakAura resets
4. Skull Mark Persistence:
   - Skull mark must remain on the designated unit until death
   - Can be temporarily overridden by diamond mark during casting
   - Must return to skull mark after temporary override ends
5. Tracks unit positions, states, and other info as needed.
6. Target history must persist through combat to ensure proper skull marking.

### 3. Nameplate Scanning
1. continous scan of nameplates once they become visible (20 yard range in classic)
2. using GUIDs passed from target-based scan, matches and confirms any unit including marks.
3. Categorizes and retains enemy info as scanned by target-based scan or nameplate scanning: current units, marked units, unmarked units, casting units and aggro units to assit with tracking and marking.
4. Tracks unit positions, states, and other info as needed.
5. Cleans up info after combat ends.

### 4. Cast Interrupt System for Diamond Marking
1. Detects interruptible casts
2. Assigns diamond (mark 3) to units casting interruptible spells - can temporarily overide skull (mark 8) or triangle (mark 4) if unit with skull or triangle is casting interruptible spells.
3. Removes diamond (mark 3) when unit is no longer casting (finished or interrupted) interruptible spells.
4. Preserves and reassigns previous mark to enemy unit after removing diamond mark.

### 5. Aggro-Based Triangle Marking
1. Assigns triangle mark to an enemy unit that has aggro on player if solo (or any player in group if in group), or if pet(s) do not have aggro on the enemy unit.   
2. Removes triangle mark when player (or players in group) lose aggro or pet gains aggro.
3. Group-aware functionality
   - Solo: Tracks players and player's pet's aggro only
   - Group: Tracks all group players and group pet's aggro
   - main goal is to establish when player(s) do have aggro from an enemy unit, or pets do not have aggro from an enemy unit and mark that enemy unit with triangle so the pet attacks and gains aggro per the profile settings.
4. Mark Priority
   - Does not override skull mark (mark 8)
   - Overrides other marks temporarily
   - Triangle mark is removed when player (or players in group) lose aggro or pet gains aggro.
   - Preserves and reassigns previous mark to enemy unit after removing triangle when player (or players in group) lose aggro.

### 6. Mark Management
1. Skull mark (mark 8) remains on enemy units until the target dies, except when the target is casting (receives diamond temporarily), then resumes as skull unless dead.
2. Always maintain marks on enemy units unless a higher priority mark needs to be set (diamond, triangle) or the enemy unit needs a mark promotion.
3. Only one unit may have a unique mark at a time but multiple units may have different marks.
4. Reapplying the same mark to the same unit will result in the mark disappearing (toggles) and should be avoided
5. Mark and stored information should be removed if the unit dies
6. Mark should be removed if the unit no longer matches the reason for the mark, (e.g. if the unit is no longer casting interruptible spells, the diamond mark should be removed, or if the unit is no longer aggro on player or the pet has aggro, the triangle mark should be removed)
7. Promotes existing marks when needed
8. Fills empty marks with unmarked enemies
9. Mark and information should be maintained if the unit is no longer in range while in combat.
10. Targets should not switch marks unless they are being overridden (then they should resume their previous mark) or promoted to a new mark.
11. Remove/clear information when combat ends.
12. avoid time out based removal of stored unit information if possible, instead rely on state or end of combat to remove or change information where possible.
13. The marks must be properly maintained because we need excellent mark persistence logic and excellent state tracking

#### State Updates:
-- Current states to track
aura_env.states = {
    marks = {},          // Current mark assignments
    aggroUnits = {},     // Units with player/group aggro
    previousMarks = {},  // Stored marks for restoration
    castingUnits = {},   // Currently casting units
    seenTargets = {}     // Target history
}

#### Validation Patterns:
Need to implement validation patterns from building_auras.txt (lines 423-454):
1. Unit validation
2. GUID validation
3. Mark validation
4. Combat state validation


#### State updates should follow pattern
allstates[guid] = {
    show = true,
    changed = true,
    unit = unit,
    mark = currentMark,
    hasAggro = hasAggro
}

#### Technical Implementation
```lua
-- Core state variables
aura_env.aggroUnits    -- Table tracking units with player/group aggro
```

#### Performance Considerations


## Performance Optimizations
Focus on successful implementation of the core functionality first.  Then optimize performance.

### 1. Update Throttling
```lua
if not aura_env.last or GetTime() - aura_env.last > 0.2 then
    aura_env.last = GetTime()
    -- Processing logic
end
```

### 2. Table Management
- Reuse existing tables
- Regular cleanup data when combat ends and expired data as needed during combat.
- Efficient state tracking

### 3. Early Exits
- Permission checks
- Throttle checks
- Invalid unit checks

## Error Prevention
- Assure proper LUA logic for weak auras addon

### 1. Unit Validation
- Existence checks
- GUID validation
- Combat state verification

### 2. State Safety
- Initialize all states
- Handle nil cases
- Validate mark assignments

### 3. Clean Up
- Remove expired casts
- Clean up dead target marks
- Maintain seen targets list

## Resources
- uses standard WoW API for wow classic

## Notes
- Designed for WoW Classic
- Optimized for combat situations

## WeakAura Implementation Guidelines

### 1. Syntax Requirements
- Use standard Lua control flow (if/else, while, for, break, return)
- Avoid Lua 5.1+ specific features like `goto` statements
- Keep within WoW's secure environment restrictions

### 2. Supported Control Flow
```lua
-- Recommended patterns
if condition then
    -- code
elseif condition then
    -- code
else
    -- code
end

for i = 1, n do
    if condition then
        break
    end
end

while condition do
    if condition then
        return
    end
end
```

### 3. Unsupported or Risky Features
- goto statements
- labels
- Complex control flow structures
- Certain Lua 5.1+ features

### 4. Best Practices
- Use early returns for flow control
- Implement clear conditional blocks
- Keep code within WeakAura's execution context
- Follow WoW API security guidelines

---
End of Documentation