# Scanner Project: Enhanced Marking System

## Table of Contents
1. Overview
2. Technical Requirements
3. Implementation Guide
4. Testing Protocol
5. Troubleshooting Guide

## 1. Overview

### 1.1 Marking Strategy
1. Dual-Layer Target Processing:
   - Primary: Target-Based Skull Assignment
     * Stores and tracks target GUID
     * 30-second timeout for lost targets
     * Immediate clearing on death/non-existence
     * Maintains priority over nameplate marking
   - Secondary: Nameplate-Based Processing
     * Processes only units in combat
     * Handles interrupt marking (diamond)
     * Manages remaining mark assignments
     * Maintains skull consistency with target system
     * Promotes marks when higher priority slots open

2. Enhanced GUID Management:
   - Skull GUID tracking with timeout
   - Safe GUID cleanup with temporary storage
   - Timestamp-based validation
   - Automatic promotion on skull clear

### 1.2 Key Features
- Robust target tracking beyond nameplate range
- 30-second timeout for lost skull targets
- Safe GUID cleanup system
- Priority-based interrupt marking
- Spell category prioritization
- Rogue CC detection
- Mark promotion system

## 2. Technical Requirements

### 2.1 State Variables
```lua
aura_env.last           -- Throttle timer
aura_env.marks          -- Current mark assignments
aura_env.castEndTimes   -- Cast tracking
aura_env.skullGUID      -- Skull target GUID
aura_env.skullTimestamp -- Last verification time
aura_env.seenTargets    -- Recently seen targets tracking
```

### 2.2 Information Flow
1. Target Processing:
   ```lua
   -- Target-based Skull Marking
   if targetGUID and UnitCanAttack("player", "target") then
       if aura_env.seenTargets[targetGUID] then
           -- Target seen twice within 5s window gets skull
           if not aura_env.skullGUID and not GetRaidTargetIndex("target") then
               SetRaidTarget("target", 8)
               aura_env.skullGUID = targetGUID
               aura_env.marks[targetGUID] = 8
           end
       else
           -- First time seeing target
           aura_env.seenTargets[targetGUID] = currentTime
       end
   end

   -- Clean seen targets after 5s
   for guid, timestamp in pairs(aura_env.seenTargets) do
       if currentTime - timestamp > 5 then
           aura_env.seenTargets[guid] = nil
       end
   end

   -- Skull GUID Management
   if aura_env.skullGUID and (currentTime - aura_env.skullTimestamp > 30) then
       local oldGUID = aura_env.skullGUID
       aura_env.skullGUID = nil
       aura_env.marks[oldGUID] = nil
   end
   ```

2. Nameplate Integration:
   ```lua
   -- Combat-only nameplate processing
   if UnitExists(unit) and UnitCanAttack("player", unit) and UnitAffectingCombat(unit) then
       local guid = UnitGUID(unit)
       if guid then
           local currentMark = GetRaidTargetIndex(unit)
           currentEnemies[guid] = unit
           
           -- Process unit for marks based on casting, CC state
           -- Track in appropriate tables (markedEnemies, unmarkedEnemies, castingUnits)
       end
   end
   ```

### 2.3 Target Selection Logic
1. Out of Combat:
   - Scans for targets when no skull exists
   - Records targets seen through /targetenemy
   - Assigns skull to targets seen twice within 5s window

2. In Combat:
   - Maintains existing skull assignments
   - Processes casting units for diamond mark
   - Promotes and fills remaining marks

3. Priority System:
   - Skull (8): Target seen multiple times
   - Diamond (3): Highest priority interruptible cast
   - Cross (7) through Triangle (5): Available for promotion/assignment

### 2.4 Scanning Mechanics
1. Target-based Scanning:
   - Uses /targetenemy macro for target cycling
   - Records target GUIDs with timestamps
   - 5-second window for skull priority
   - 30-second timeout for skull maintenance

2. Nameplate Scanning:
   - Processes up to 40 nameplates
   - Combat-only processing
   - Tracks casting and CC states
   - Maintains mark consistency

### 2.3 Mark Priority System
1. Diamond (3):
   - Reserved for interruptible casts
   - Prioritized by spell type:
     * Healing (Priority 4)
     * CC (Priority 3)
     * Damage (Priority 2)
     * Other (Priority 1)

2. Standard Marks:
   - Skull (8) - Target assigned
   - Cross (7)
   - Circle (2)
   - Square (6)
   - Moon (4)
   - Star (1)
   - Triangle (5)

### 2.4 Spell Categories
```lua
HEALING_SPELLS  -- Heals, including dungeon-specific
CC_SPELLS       -- Polymorph, Shackle, etc.
DAMAGE_SPELLS   -- Major damage casts
```

## 3. Implementation Guide

### 3.1 Core Components
1. Target System:
   - Dual-layer target processing:
     * Primary: Target cycling with GUID memory
     * Secondary: Nameplate-based processing
   - 5-second window for target priority
   - 30-second timeout validation
   - Safe GUID cleanup

2. Nameplate System:
   - Combat-only unit detection
   - Cast tracking and prioritization
   - Interrupt mark management (diamond)
   - Mark promotion and filling

3. State Management:
   ```lua
   -- Core state variables
   aura_env.last = aura_env.last or 0              -- Throttle timer
   aura_env.marks = aura_env.marks or {}           -- Mark assignments
   aura_env.castEndTimes = aura_env.castEndTimes or {} -- Cast tracking
   aura_env.skullGUID = aura_env.skullGUID or nil  -- Skull target
   aura_env.skullTimestamp = aura_env.skullTimestamp or GetTime() -- Skull verification
   aura_env.seenTargets = aura_env.seenTargets or {} -- Target tracking
   ```

### 3.2 Processing Flow
1. Target Processing:
   ```lua
   -- Record and process current target
   if targetGUID and UnitCanAttack("player", "target") then
       if aura_env.seenTargets[targetGUID] then
           -- Seen twice within window = skull priority
       else
           -- First sighting = record timestamp
       end
   end

   -- Clean expired records
   for guid, timestamp in pairs(aura_env.seenTargets) do
       if currentTime - timestamp > 5 then
           aura_env.seenTargets[guid] = nil
       end
   end
   ```

2. Nameplate Integration:
   ```lua
   -- Process each nameplate
   for i = 1, 40 do
       local unit = "nameplate"..i
       if UnitExists(unit) and UnitCanAttack("player", unit) and UnitAffectingCombat(unit) then
           -- Process unit state
           -- Track marks and casting
           -- Handle CC states
       end
   end
   ```

3. Mark Management:
   ```lua
   -- Diamond mark for casters
   if selectedUnit then
       if selectedUnit.currentMark ~= DIAMOND then
           SetRaidTarget(selectedUnit.unit, DIAMOND)
       end
       markedEnemies[DIAMOND] = {guid = selectedUnit.guid, unit = selectedUnit.unit}
   end

   -- Promote and fill remaining marks
   PromoteMarks(markedEnemies, MARKS)
   ```

### 3.3 Error Prevention
1. GUID Safety:
   - Store GUIDs before clearing
   - Validate existence before marking
   - Clean expired records
   - Handle combat state transitions

2. Mark Consistency:
   - Verify before assignment
   - Handle mark collisions
   - Maintain priority system
   - Clean orphaned marks

### 3.4 Performance Optimization
1. Throttling:
   ```lua
   if not aura_env.last or GetTime() - aura_env.last > 0.2 then
       -- Process updates
   end
   ```

2. State Management:
   - Clean expired records
   - Minimize table iterations
   - Efficient GUID tracking
   - Combat-only processing

### 3.5 Version Control and Compatibility

1. Version Management:
   - Maintain working reference version (scanner.lua)
   - Test new features in separate file (scanner_test.lua)
   - Document core functionality that must be preserved
   - Explicitly state when deprecating features

2. Conflict Prevention:
   ```lua
   -- Example: Diamond mark management
   -- Must maintain both immediate and cleanup functionality
   if priority > 0 then
       -- Assign diamond mark
       castingUnits[guid] = {
           -- ... casting unit data
       }
   elseif currentMark == DIAMOND then
       -- Remove diamond when no longer casting
       SetRaidTarget(unit, 0)
   end
   ```

3. Core Functionality Checklist:
   - Nameplate-based scanning
   - Target-based skull marking
   - Diamond mark management
   - Mark promotion system
   - CC state handling
   - GUID tracking and cleanup
   - Performance throttling

4. Integration Testing:
   - Verify new features don't break existing ones
   - Test interaction between systems
   - Check mark cleanup and reassignment
   - Validate state management
   - Monitor performance impact

5. Change Documentation:
   ```lua
   -- When adding new functionality:
   -- 1. Document the existing behavior
   -- 2. Identify potential conflicts
   -- 3. Test interaction with other systems
   -- 4. Verify cleanup and edge cases
   ```

6. System Dependencies:
   - Target system → Skull marking
   - Cast detection → Diamond marking
   - Mark promotion → Both systems
   - CC detection → Mark removal
   - GUID tracking → All systems

7. Regression Prevention:
   - Keep reference implementation
   - Document critical behaviors
   - Test all mark interactions
   - Verify cleanup routines
   - Monitor state consistency

## 4. Testing Protocol

### 4.1 Verified Functionality
- [x] Target-based skull assignment
- [x] Target cycling memory
- [x] 5-second priority window
- [x] 30-second skull timeout
- [x] Combat-only processing
- [x] Diamond mark priority
- [x] Mark promotion system
- [x] CC state handling

### 4.2 Current Goals
1. Target System:
   - [x] GUID memory implementation
   - [x] Priority window timing
   - [x] Cleanup routines
   - [ ] Edge case handling

2. Integration:
   - [x] Combat state handling
   - [x] Mark consistency
   - [ ] Performance monitoring
   - [ ] Error logging

### 4.3 Test Cases
1. Target Cycling:
   - Multiple target cycling within 5s
   - Target persistence beyond range
   - Combat state transitions
   - Mark consistency

2. Nameplate Processing:
   - Cast detection accuracy
   - Priority system validation
   - CC state handling
   - Mark promotion logic

### 4.4 Testing Framework

1. Scenario Testing:
   ```lua
   local TestScenarios = {
       STATES = {
           IDLE = 1,
           COMBAT = 2,
           CASTING = 3,
           MARKED = 4,
           CLEANUP = 5
       },
       
       scenarios = {
           basic_marking = {
               setup = function()
                   return {
                       units = {
                           ["Unit1"] = {guid = "GUID1", casting = false, mark = nil},
                           ["Unit2"] = {guid = "GUID2", casting = true, spell = "Heal"}
                       },
                       expected = {
                           ["GUID1"] = {mark = 8},  -- Should get skull
                           ["GUID2"] = {mark = 3}   -- Should get diamond
                       }
                   }
               end
           },
           mark_promotion = {
               setup = function()
                   return {
                       units = {
                           ["Unit1"] = {guid = "GUID1", mark = 7},  -- Cross
                           ["Unit2"] = {guid = "GUID2", dead = true, mark = 8}  -- Skull
                       },
                       expected = {
                           ["GUID1"] = {mark = 8},  -- Should be promoted to skull
                           ["GUID2"] = {mark = nil} -- Mark should be cleared
                       }
                   }
               end
           },
           cast_priority = {
               setup = function()
                   return {
                       units = {
                           ["Unit1"] = {guid = "GUID1", casting = true, spell = "Heal"},
                           ["Unit2"] = {guid = "GUID2", casting = true, spell = "Fireball"}
                       },
                       expected = {
                           ["GUID1"] = {mark = 3},  -- Healer gets diamond priority
                           ["GUID2"] = {mark = nil} -- Lower priority cast
                       }
                   }
               end
           }
       }
   }
   ```

2. State Tracking:
   - GUID persistence through nameplate changes
   - Mark assignments and promotions
   - Cast state transitions
   - Combat state changes
   - Cleanup timing

3. Validation Points:
   ```lua
   local ValidationChecks = {
       mark_consistency = function(scenario)
           -- Verify marks are consistent with priorities
           for guid, data in pairs(scenario.expected) do
               if data.mark ~= GetRaidTargetIndex(data.unit) then
                   return false, "Mark mismatch for "..guid
               end
           end
           return true
       end,
       
       guid_tracking = function(scenario)
           -- Verify GUIDs are properly tracked
           for guid, _ in pairs(aura_env.seenTargets) do
               if not scenario.units[guid] then
                   return false, "Tracking non-existent GUID"
               end
           end
           return true
       end,
       
       cleanup_timing = function(scenario)
           -- Verify cleanup routines work correctly
           local currentTime = GetTime()
           for guid, timestamp in pairs(aura_env.seenTargets) do
               if currentTime - timestamp > 5 and 
                  not scenario.units[guid].persistent then
                   return false, "Failed to cleanup expired GUID"
               end
           end
           return true
       end
   }
   ```

4. Performance Metrics:
   ```lua
   local PerformanceTracking = {
       metrics = {},
       
       track = function(self, operation, startTime)
           local duration = GetTime() - startTime
           self.metrics[operation] = self.metrics[operation] or {
               count = 0,
               total_time = 0,
               max_time = 0
           }
           self.metrics[operation].count = self.metrics[operation].count + 1
           self.metrics[operation].total_time = self.metrics[operation].total_time + duration
           self.metrics[operation].max_time = math.max(self.metrics[operation].max_time, duration)
       end,
       
       report = function(self)
           for op, data in pairs(self.metrics) do
               print(string.format("%s: avg=%.3fms max=%.3fms count=%d",
                   op, data.total_time/data.count*1000, data.max_time*1000, data.count))
           end
       end
   }
   ```

5. Integration Testing:
   - Combat state transitions
   - Multiple target cycling
   - Mark promotion chains
   - Priority system validation
   - Cleanup routine verification
   - Edge case handling

This framework allows systematic testing of the scanner functionality while tracking performance and correctness metrics.

## 5. Troubleshooting Guide

### 5.1 Common Issues
1. Target Processing:
   - Verify target cycling
   - Check GUID recording
   - Validate priority window
   - Monitor cleanup routines

2. Mark Management:
   - Check mark assignments
   - Verify promotion logic
   - Monitor combat transitions
   - Validate CC handling

### 5.2 Debug Logging
Add debug statements for:
- Target acquisition
- GUID recording
- Priority assignments
- State cleanup
- Mark transitions

### 5.3 Performance Monitoring
1. State Size:
   - seenTargets table
   - marks table
   - castEndTimes table

2. Processing Time:
   - Target cycling
   - Nameplate scanning
   - Mark management
   - State cleanup

