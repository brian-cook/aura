Instructions for Working on the Simulator

1. Gather Accurate Information:
   - Use [Icy Veins](https://www.icy-veins.com/) and [Wowpedia](https://wowpedia.fandom.com/wiki/Wowpedia) for class-specific rotations and ability damage.
   - Use [Wowhead](https://www.wowhead.com/classic/items/weapons/daggers#items;0+3+19) for weapon information.
   - Use [Marrow Compendium](https://bookdown.org/marrowwar/marrow_compendium/mechanics.html) for detailed mechanics.
   - Additional Resources:
     - [Noxxic](https://www.noxxic.com/wow-classic/)
     - [Elitist Jerks](https://web.archive.org/web/20190501000000*/elitistjerks.com)
     - [Classic WoWhead](https://classic.wowhead.com/)
     - [WoW Classic Subreddit](https://www.reddit.com/r/classicwow/)
     - [Warcraft Logs](https://classic.warcraftlogs.com/)
     - WoW Classic Discord Servers

2. Update the Simulation:
   - Update the damage amounts and mechanics in the simulation based on the gathered information.
   - Example:
     ```python
     def backstab(self):
         if self.use_backstab and self.energy >= 60:
             self.energy -= 60
             self.combo_points += 1
             damage = self.calculate_damage(150, 1.5, 150)  # Base damage, multiplier, and additional damage
             self.damage += damage
             self.time += self.gcd
             print(f"Used Backstab: Time={self.time}, Energy={self.energy}, Combo Points={self.combo_points}, Damage={self.damage}")
             return True
         return False
     ```

3. Implement Hit and Crit Chance Adjustments:
   - Adjust hit and crit chances based on level differences between the player and the target.
   - Include glancing blows for melee attacks.
   - Example:
     ```python
     def calculate_damage(self, base_damage, multiplier, additional_damage=0):
         if random.random() > self.hit_chance:
             print(f"Missed attack: Time={self.time}")
             return 0
         weapon_damage = random.randint(self.weapon_damage_min, self.weapon_damage_max)
         damage = base_damage + weapon_damage * multiplier + additional_damage
         damage = damage * (1 - self.target_armor / (self.target_armor + 400 + 85 * self.level))  # Armor reduction
         if random.random() < self.crit_chance:
             damage *= 2
             print(f"Critical hit: Time={self.time}, Damage={damage}")
         elif random.random() < 0.4:  # Glancing blow chance
             damage *= 0.7
             print(f"Glancing blow: Time={self.time}, Damage={damage}")
         return damage
     ```

4. Implement Buffs and Debuffs:
   - Implement common buffs and debuffs that affect damage output (e.g., Slice and Dice, poisons).
   - Example:
     ```python
     def slice_and_dice(self):
         if self.use_buffs and self.energy >= 25 and self.combo_points > 0:
             self.energy -= 25
             self.slice_and_dice_active = True
             self.slice_and_dice_end_time = self.time + 30  # Slice and Dice duration
             self.time += self.gcd
             print(f"Used Slice and Dice: Time={self.time}, Energy={self.energy}, Combo Points={self.combo_points}")
             return True
         return False
     ```

5. Implement Cooldown Management:
   - Implement cooldown management for abilities with cooldowns (e.g., Adrenaline Rush).
   - Example:
     ```python
     def adrenaline_rush(self):
         if self.energy >= 0:
             self.adrenaline_rush_active = True
             self.adrenaline_rush_end_time = self.time + 15  # Adrenaline Rush duration
             self.time += self.gcd
             print(f"Used Adrenaline Rush: Time={self.time}")
             return True
         return False
     ```

6. Test the Simulation:
   - Run the simulation to ensure it accurately reflects the updated information.
   - Example:
     ```python
     rogue = Rogue(level=10, use_backstab=False, use_buffs=False)
     damage = rogue.simulate_rotation(60, profile)
     print(f"Total damage dealt in 60 seconds: {damage}")
     ```

7. Analyze Results:
   - Compare the damage output with different profile configurations.
   - Adjust the profile based on the simulation results to optimize combat effectiveness.

8. Document Changes:
   - Keep track of any changes made to the simulation and the profile.
   - Update the instructions file with any new information or steps.

If you need further modifications or have additional questions, please let me know!